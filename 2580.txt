#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int arr[9][9];
bool row[9][10];
bool col[9][10];
bool small[9][10];

int change(int x, int y){
    return (y/3)*3 + x/3;
}

void dfs(int c){
    int y{c/9};
    int x{c%9};
    
    if (c == 81) {
        for (int i{}; i < 9; i++) {
            for (int j{}; j < 9; j++) {
                cout << arr[i][j] << " ";
            }
            cout << '\n';
        }
        exit(0);
    }
    
    if (arr[y][x]) {
        dfs(c+1);
    } else {
        for (int k{1}; k <= 9; k++) {
            if(!row[y][k] && !col[x][k] && !small[change(x, y)][k]){
                arr[y][x] = k;
                row[y][k] = true;
                col[x][k] = true;
                small[change(x, y)][k] = true;
                dfs(c+1);
                arr[y][x] = 0;
                row[y][k] = false;
                col[x][k] = false;
                small[change(x, y)][k] = false;
            }
        }
    }
}

int main(void) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    for (int i{}; i < 9; i++) {
        for (int j{}; j < 9; j++) {
            cin >> arr[i][j];
            if (arr[i][j]) {
                row[i][arr[i][j]] = true;
                col[j][arr[i][j]] = true;
                small[change(j, i)][arr[i][j]] = true;
            }
        }
    }
    
    dfs(0);

    return 0;
}

// 빈칸(arr[i][j] == 0)에서 시작. 큐로 빈칸의 좌표 저장 후 큐의 front를 꺼내서 dfs하고 삭제를 반복. 만약 dfs 완료했을 때 적절한 숫자가 없을 때(가로, 세로, 3*3에 들어갈 숫자가 하나가 아닐 때 or 없을 때) 큐의 마지막으로 보내 다른 곳이 먼저 처리된 후 적절한 숫자 찾을 수 있게 함.
// dfs는 인자로 들어간 좌표의 가로, 세로, 3*3배열에 모두 안들어있는 숫자 확인 후 좌표에 그 숫자를 넣고 dfs 종료.
// dfs안에 반복문 3개(가로, 세로, 3*3배열) 사용하여 조건 체크하게 구현하여 예제 입력은 맞았으나 틀려서 반례 찾아보니 모든 좌표에 0이 들어있는 경우 비교할 대상이 없어 무한 루프 돌게 됨.
// -> 가로, 세로, 3*3을 모두 체크 했을 때, 들어갈 수 있는 숫자가 1개가 아니라면, 일단 그 중 하나 넣고 다음 빈칸을 진행한 후 나중에 수정해야 함.

// 결국 답 못찾아 다른 사람 코드 보고 구현.
// 백트래킹 사용.
//처음에 코드 이해하기 어려웠는데 직접 코드 치면서 디버깅 해보니 이해할 수 있었음. 나중에 비슷한 문제 나오면 이 방법을 생각할 수 있을지는 모르겠음. 백트래킹 구현 방법이라고 기억해두기.
가로, 세로, 3*3 배열에 1~9까지의 숫자가 있는지 체크할 수 있는 배열을 만들어 놓고, 첫번째 칸부터 dfs 진행하면서(dfs(0)) 칸에 이미 숫자가 있으면 다음칸으로 넘어가고 빈칸이라면 가로, 세로, 3*3에 없는 숫자를 1~9까지 체크하여 조건에 해당하는 숫자를 그 칸에 넣고, dfs(count + 1)로 다음 칸 진행. 만약 어떤 수도 삽입할 수 없다면 dfs종료되고 전 단계의 dfs로 돌아감(이 때 체크한 배열들 모두 원래대로 돌려놓음). 이 과정 반복하며 count가 81(9*9)가 될 때 배열에 저장된 수들을(정답을) 출력.

// 참고) 백트래킹의 정의
// https://chanhuiseok.github.io/posts/algo-23/

// 해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더이상 가지 않고 되돌아갑니다.

// 즉, 코딩에서는 반복문의 횟수까지 줄일 수 있으므로 효율적입니다.

// 이를 가지치기라고 하는데, 불필요한 부분을 쳐내고 최대한 올바른 쪽으로 간다는 의미입니다.

// 일반적으로, 불필요한 경로를 조기에 차단할 수 있게 되어 경우의 수가 줄어들지만, 만약 N!의 경우의 수를 가진 문제에서 최악의 경우에는 여전히 지수함수 시간을 필요로 하므로 처리가 불가능 할 수도 있습니다. 가지치기를 얼마나 잘하느냐에 따라 효율성이 결정되게 됩니다.

// 정리하자면, 백트래킹은 모든 가능한 경우의 수 중에서 특정한 조건을 만족하는 경우만 살펴보는 것입니다.

// 즉 답이 될 만한지 판단하고 그렇지 않으면 그 부분까지 탐색하는 것을 하지 않고 가지치기 하는 것을 백트래킹이라고 생각하면 됩니다.
// 주로 문제 풀이에서는 DFS 등으로 모든 경우의 수를 탐색하는 과정에서, 조건문 등을 걸어 답이 절대로 될 수 없는 상황을 정의하고, 그러한 상황일 경우에는 탐색을 중지시킨 뒤 그 이전으로 돌아가서 다시 다른 경우를 탐색하게끔 구현할 수 있습니다.