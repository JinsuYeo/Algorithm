#include <iostream>
#include <algorithm>

using namespace std;

const int MAX = 100001;
const int MOD = 1000000009;

int T, N;
int dp[MAX][4];

int main(void) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    dp[1][1] = 1;
    dp[2][2] = 1;
    dp[3][1] = 1;
    dp[3][2] = 1;
    dp[3][3] = 1;
    for (int i{4}; i < MAX; i++) {
        dp[i][1] = (dp[i-1][2] + dp[i-1][3]) % MOD;
        dp[i][2] = (dp[i-2][1] + dp[i-2][3]) % MOD;
        dp[i][3] = (dp[i-3][1] + dp[i-3][2]) % MOD;
    }
    
    cin >> T;
    for(int i{}; i < T; i++){
        cin >> N;
        cout << ((dp[N][1] + dp[N][2]) % MOD + dp[N][3]) % MOD << '\n';
    }
    
    return 0;
}

// 1, 2, 3을 더해서 N을 만드는 경우의 수를 구해서 출력해야 함. 이 때, 같은 수를 연속해 사용할 수 없음.
// N의 경우의 수를 1~10까지 구한 뒤 규칙을 이리저리 찾아봤지만 규칙은 없었음.
// dp를 이차원 배열로 해서규칙을 찾으려 했지만 어떻게 조건을 설정해야 할 지 몰라서 결국 다른 사람 풀이 보고풂.
// > DP 문제 풀기 위해서는 DP[i]를 점화식으로 나타낼 수 있어야 함.
// 이 경우, 이차원 배열 사용해 하는데, 연속으로 같은 수 사용할 수 없다는 조건과. 1, 2, 3만 사용할 수 있다는 조건을 이용해 점화식 구하여야 함.
// dp[N][i](1 <= N <= 100000, 1 <= i <=3)가 i를 마지막으로 더해 N을 만드는 경우의 수라고 할 때(ex) dp[4][1]은 1 + 2 + 1, 3 + 1로 2개), N을 만드는 경우의 수는 dp[N][1] + dp[N][2] + dp[N][3]를 구하여 출력하면 됨(구할 때 마다 mod연산 해주어야 함).
// 이 때,
// dp[N][1] = dp[N-1][2] + dp[N-1][3]; (n-1을 만드는 수 중 1을 마지막으로 더하는 수가 아닌 수, 즉 (n-1) + 1이 가능한 수)
// dp[N][2] = dp[N-2][1] + dp[N-2][3]; (n-2를 만드는 수 중 2를 마지막으로 더하는 수가 아닌 수, 즉 (n-2) + 2가 가능한 수)
// dp[N][3] = dp[N-3][1] + dp[N-3][2]; (n-3을 만드는 수 중 3을 마지막으로 더하는 수가 아닌 수, 즉 (n-3) + 3이 가능한 수).