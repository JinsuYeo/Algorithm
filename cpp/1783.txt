#include <iostream>
#include <algorithm>

using namespace std;

int n, m, c;

int main(void) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> n >> m;
    // n이 세로, m이 가로
    
    if (n <= 1) {
        c = 1;
    } else if(n == 2 && m >= 7) {
        c = 4;
    } else if(n == 2 && m < 7) {
        c = (m-1)/2 + 1;
    } else if(n >= 3 && m >= 7) {
        c = m - 2;
    } else if(n >= 3 && m < 7) {
        if (m >= 4) {
            c = 4;
        } else c = m;
    }
   
    cout << c;
    
    return 0;
}

// 처음에 그림을 그려서 생각했는데 너무 복잡하게 생각한 듯 하다. 가로 길이, 세로 길이 저장해서 한번 옮길 때마다 n-2, m-1 or n-1, m-2 이런 식으로 n과 m이 0이 될 때까지 반복해서 구현하려고 했으나, 이동 횟수가 4이상 일 때 모든 이동방법을 써야한다는 조건과 만약 n-1, m-2로 오른쪽으로 한칸, 위로 2칸을 구현한다치면 오른쪽으로 한칸 아래쪽으로 한칸 가는 경우 조건을 어떻게 맞춰야 할 지(m > 1 같은 조건으로는 아래로 갈 때 검사 불가) 같은 처음에 생각하지 못한 문제들이 구현하려니 하나 둘씩 늘어나서 마지막에는 내가 짜놓고도 뭐가 뭔지 모르겠어서 디버깅도 불가능할 정도였다.

// 결국 다른 사람 코드를 보고 짜려고 했으나 코드는 안보고 재귀식?같이 체크해야 할 몇가지 조건으로 나누어 놓으신걸 보고 다시 그림 그려서 생각하고 코드를 짜서 정답을 맞췄다.

// 참조)
// https://jaimemin.tistory.com/598

// y가 1이하일 때는 한칸(원래 위치)밖에 갈 수 없고, y가 2일때는 x가 7이상이면 4(모든 이동 방법 사용할 수 없으므로 3번만 이동 가능), 그 전에는 (x-1)/2 + 1이 이동한 칸의 개수가 되고, y가 3 이상일 때, x가 7 이상이면 x - 2개, x가 6 이하이면 1, 2, 3, 4, 4, 4개가 된다(그림을 보면 이해하기 쉽다).

// 그리디는 전에 풀었던 문제들과 다르게 구현이 어렵지 않고 알고리즘을 생각하는게 어려운 문제인 것 같다(최적의 상황만을 쫓아 최종 결과를 도출해야 함).