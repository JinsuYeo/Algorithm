#include <iostream>
#include <algorithm>
#include <array>
#include <string>

using namespace std;
int arr[1000][1000];
int R, C;
string result;

int main(void) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
        
    cin >> R >> C;
    for (int i{}; i < R; i++) {
        for (int j{}; j < C; j++) {
            cin >> arr[i][j];
        }
    }
    
    if(R%2) {
        for (int i{}; i < R; i++) {
            for (int j{}; j < C-1; j++) {
                if (i % 2 == 0) {
                    result += 'R';
                } else {
                    result += 'L';
                }
            }
            if (i != R - 1) {
                result += 'D';
            }
        }
    } else if(!(R%2) && C%2) {
        for (int j{}; j < C; j++) {
            for (int i{}; i < R-1; i++) {
                if (j % 2 == 0) {
                    result += 'D';
                } else {
                    result += 'U';
                }
            }
            if (j != C-1) {
                result += 'R';
            }
        }
    } else if(!(R%2) && !(C%2)) {
        int min_v{987654321};
        int y{}, x{};
        for (int i{}; i < R; i++) {
            for (int j{}; j < C; j++) {
                if ((i + j) % 2 && min_v > arr[i][j]) {
                    min_v = arr[i][j];
                    y = i;
                    x = j;
                }
            }
        }
        int nR = y%2 ? y-1 : y;
        for (int i{}; i < nR; i++) {
            for (int j{}; j < C - 1; j++) {
                if (i%2 == 0) {
                    result += 'R';
                } else {
                    result += 'L';
                }
            }
            result += 'D';
        }
        int nC = x;
        for (int i{}; i < nC; i++) {
            if (i % 2 == 0) {
                result += "DR";
            } else {
                result += "UR";
            }
        }
        for (int i{nC}; i < C - 1; i++) {
            if (i % 2== 0) {
                result += "RD";
            } else {
                result += "RU";
            }
        }
        if (y % 2 == 0) {
            nR = R - (y+2);
        } else {
            nR = R - (y+1);
        }
        for (int i{}; i < nR; i++) {
            result += 'D';
            for (int j{}; j < C - 1; j++) {
                if (i % 2 == 0) {
                    result += 'L';
                } else {
                    result += 'R';
                }
            }
        }
    }
    
    cout << result << "\n";
    
    return 0;
}

// 상하좌우로 이동 가능.
// 각 칸은 한번만 이동 가능(재방문 불가).
// 각 칸에 수 있고 수가 최대가 되도록 0,0에서 R-1, C-1 로 이동.

// 그림을 그려서 생각해보니 R과 C가 모두 짝수가 아닐 때는 모든 칸에 방문 가능했음.

// 예를 들어 R(y값)이 홀수일 때는 0에서부터 시작해서,
// R이 짝수(0, 2, 4, 6...)일 때는 오른쪽으로 쭉 가다가 끝나면(오른쪽으로 더 갈 수 없으면) 아래로 가고, R이 홀수일 때는 왼쪽으로 쭉가다가 아래로 가고를 R이 R - 1일 때까지 반복(R-1일 때는 아래로 더 내려가지 않음).

// R이 홀수이고 C가 홀수일 때는 아래로가다가 오른쪽으로 한칸가고 다시 위로가다가 오른쪽으로 한칸가고... 를 반복하다가 C-1일때는 아래로 내려가고 오른쪽으로는 가지 않음.

// R, C가 모두 짝수일 때는 좌표중 어디가 가장 작은 값인지 찾아야 하는데, 나는 처음에 (R-1, C-2) or (R-1, 0) or (R-2, C-1)만 찾아서 피하면 되는 줄 알았음. 그래서 구현하고 채점 결과 틀렸습니다가 나오길래 반례 찾아보니 (0, 1)이 가장 작은 값일 때 틀렸음. -> 내가 생각한 좌표만 고려하는 것이 아니라 다른 곳에 최솟값 있을 때에도 피해갈 수 있다는 것 깨닫고 어디 어디를 피할 수 있나 생각해보니 R이 짝수 C가 홀수이거나, 반대로 R이 홀수, C가 짝수인 부분들은 한칸만 피해서 갈 수 있었음. ex) (0,1), (0,3), (1, 2), (1, 4)...등 그림으로 보면 쉽게 파악 가능.

// 최솟값 좌표 찾아서 그 전까지는 가로세로 그리며 다 방문하고 좌표의 y값이 홀수일 때는  y-2까지 반복, y값이 짝수일 때는 y-1까지 반복(가장 왼쪽에서부터 시작해야 하기 때문). 마찬가지로 그림 그려보면 이유 알 수 있음. 그 후 아래 위 아래 위 한칸씩 이동을 반복하며 한 칸씩 오른쪽으로 이동하다가 좌표있을 때는 피해서 오른쪽 끝까지 반복(이 때 y는 2칸만 사용).
// 그 후 가장 오른쪽에 위치하니까 아래로 한칸 내려와서 왼쪽으로 가다 내려와서 오른쪽으로가다가... 하면서 칸 모두 이동하면 됨.

// 글로 쓰기 어려운데 그림으로 보면 쉬움. + 글로 쓰기 어렵다는 건 코드로 구현하기는 더 어렵다는 뜻 -> 좀 더 코드로 구현하기 쉽고 이해하기도 쉽게 글로 표현하는 능력을 길러야 할 듯. + markdown으로 이미지 첨부하는 것 등 좀 더 깔끔하게 정리하는 방법 공부하기.

// 결국 알고리즘은 얼추 생각했는데 구현이 도저히 안되어서(예시는 통과가 되는데 틀렸습니다 나와서) 다른 사람 코드를 보고 구현.
// 알고리즘 자체는 비슷하나 구현이 훨씬 더 이해하기도 쉽고 구현하기도 쉬웠음. + 그림이 없는데도 블로그의 글을 보고 알고리즘을 이해하기도 쉬웠음. 이런 부분 배우자.

// 그리디 알고리즘 사용하는 어려운 문제 중 그래도 알고리즘을 정답에 가깝게 생각한 가장 첫 문제인 듯.